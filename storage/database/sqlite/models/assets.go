// Code generated by BobGen sqlite v0.22.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/kodeshack/stuff/storage/database/sqlite/types"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/sqlite"
	"github.com/stephenafamo/bob/dialect/sqlite/dialect"
	"github.com/stephenafamo/bob/dialect/sqlite/im"
	"github.com/stephenafamo/bob/dialect/sqlite/sm"
	"github.com/stephenafamo/bob/dialect/sqlite/um"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
)

// Asset is an object representing the database table.
type Asset struct {
	ID               int64                                      `db:"id,pk" `
	ParentAssetID    null.Val[int64]                            `db:"parent_asset_id" `
	Status           string                                     `db:"status" `
	Tag              null.Val[string]                           `db:"tag" `
	Name             string                                     `db:"name" `
	Category         string                                     `db:"category" `
	Model            null.Val[string]                           `db:"model" `
	ModelNo          null.Val[string]                           `db:"model_no" `
	SerialNo         null.Val[string]                           `db:"serial_no" `
	Manufacturer     null.Val[string]                           `db:"manufacturer" `
	Notes            null.Val[string]                           `db:"notes" `
	ImageURL         null.Val[string]                           `db:"image_url" `
	ThumbnailURL     null.Val[string]                           `db:"thumbnail_url" `
	WarrantyUntil    null.Val[types.SQLiteDatetime]             `db:"warranty_until" `
	CustomAttrs      null.Val[types.SQLiteJSON[map[string]any]] `db:"custom_attrs" `
	CheckedOutTo     null.Val[int64]                            `db:"checked_out_to" `
	Location         null.Val[string]                           `db:"location" `
	PositionCode     null.Val[string]                           `db:"position_code" `
	PurchaseSupplier null.Val[string]                           `db:"purchase_supplier" `
	PurchaseOrderNo  null.Val[string]                           `db:"purchase_order_no" `
	PurchaseDate     null.Val[types.SQLiteDatetime]             `db:"purchase_date" `
	PurchaseAmount   null.Val[int64]                            `db:"purchase_amount" `
	PurchaseCurrency null.Val[string]                           `db:"purchase_currency" `
	CreatedBy        int64                                      `db:"created_by" `
	CreatedAt        types.SQLiteDatetime                       `db:"created_at" `
	UpdatedAt        types.SQLiteDatetime                       `db:"updated_at" `

	R assetR `db:"-" `
}

// AssetSlice is an alias for a slice of pointers to Asset.
// This should almost always be used instead of []*Asset.
type AssetSlice []*Asset

// Assets contains methods to work with the assets table
var Assets = sqlite.NewTablex[*Asset, AssetSlice, *AssetSetter]("", "assets")

// AssetsQuery is a query on the assets table
type AssetsQuery = *sqlite.ViewQuery[*Asset, AssetSlice]

// AssetsStmt is a prepared statment on assets
type AssetsStmt = bob.QueryStmt[*Asset, AssetSlice]

// assetR is where relationships are stored.
type assetR struct {
	CreatedByUser       *User      // fk_assets_0
	CheckedOutToUser    *User      // fk_assets_1
	Tag                 *Tag       // fk_assets_2
	ParentAsset         *Asset     // fk_assets_3
	ReverseParentAssets AssetSlice // fk_assets_3__self_join_reverse
}

// AssetSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type AssetSetter struct {
	ID               omit.Val[int64]                                `db:"id,pk"`
	ParentAssetID    omitnull.Val[int64]                            `db:"parent_asset_id"`
	Status           omit.Val[string]                               `db:"status"`
	Tag              omitnull.Val[string]                           `db:"tag"`
	Name             omit.Val[string]                               `db:"name"`
	Category         omit.Val[string]                               `db:"category"`
	Model            omitnull.Val[string]                           `db:"model"`
	ModelNo          omitnull.Val[string]                           `db:"model_no"`
	SerialNo         omitnull.Val[string]                           `db:"serial_no"`
	Manufacturer     omitnull.Val[string]                           `db:"manufacturer"`
	Notes            omitnull.Val[string]                           `db:"notes"`
	ImageURL         omitnull.Val[string]                           `db:"image_url"`
	ThumbnailURL     omitnull.Val[string]                           `db:"thumbnail_url"`
	WarrantyUntil    omitnull.Val[types.SQLiteDatetime]             `db:"warranty_until"`
	CustomAttrs      omitnull.Val[types.SQLiteJSON[map[string]any]] `db:"custom_attrs"`
	CheckedOutTo     omitnull.Val[int64]                            `db:"checked_out_to"`
	Location         omitnull.Val[string]                           `db:"location"`
	PositionCode     omitnull.Val[string]                           `db:"position_code"`
	PurchaseSupplier omitnull.Val[string]                           `db:"purchase_supplier"`
	PurchaseOrderNo  omitnull.Val[string]                           `db:"purchase_order_no"`
	PurchaseDate     omitnull.Val[types.SQLiteDatetime]             `db:"purchase_date"`
	PurchaseAmount   omitnull.Val[int64]                            `db:"purchase_amount"`
	PurchaseCurrency omitnull.Val[string]                           `db:"purchase_currency"`
	CreatedBy        omit.Val[int64]                                `db:"created_by"`
	CreatedAt        omit.Val[types.SQLiteDatetime]                 `db:"created_at"`
	UpdatedAt        omit.Val[types.SQLiteDatetime]                 `db:"updated_at"`
}

func (s AssetSetter) SetColumns() []string {
	vals := make([]string, 0, 26)
	if !s.ID.IsUnset() {
		vals = append(vals, "id")
	}

	if !s.ParentAssetID.IsUnset() {
		vals = append(vals, "parent_asset_id")
	}

	if !s.Status.IsUnset() {
		vals = append(vals, "status")
	}

	if !s.Tag.IsUnset() {
		vals = append(vals, "tag")
	}

	if !s.Name.IsUnset() {
		vals = append(vals, "name")
	}

	if !s.Category.IsUnset() {
		vals = append(vals, "category")
	}

	if !s.Model.IsUnset() {
		vals = append(vals, "model")
	}

	if !s.ModelNo.IsUnset() {
		vals = append(vals, "model_no")
	}

	if !s.SerialNo.IsUnset() {
		vals = append(vals, "serial_no")
	}

	if !s.Manufacturer.IsUnset() {
		vals = append(vals, "manufacturer")
	}

	if !s.Notes.IsUnset() {
		vals = append(vals, "notes")
	}

	if !s.ImageURL.IsUnset() {
		vals = append(vals, "image_url")
	}

	if !s.ThumbnailURL.IsUnset() {
		vals = append(vals, "thumbnail_url")
	}

	if !s.WarrantyUntil.IsUnset() {
		vals = append(vals, "warranty_until")
	}

	if !s.CustomAttrs.IsUnset() {
		vals = append(vals, "custom_attrs")
	}

	if !s.CheckedOutTo.IsUnset() {
		vals = append(vals, "checked_out_to")
	}

	if !s.Location.IsUnset() {
		vals = append(vals, "location")
	}

	if !s.PositionCode.IsUnset() {
		vals = append(vals, "position_code")
	}

	if !s.PurchaseSupplier.IsUnset() {
		vals = append(vals, "purchase_supplier")
	}

	if !s.PurchaseOrderNo.IsUnset() {
		vals = append(vals, "purchase_order_no")
	}

	if !s.PurchaseDate.IsUnset() {
		vals = append(vals, "purchase_date")
	}

	if !s.PurchaseAmount.IsUnset() {
		vals = append(vals, "purchase_amount")
	}

	if !s.PurchaseCurrency.IsUnset() {
		vals = append(vals, "purchase_currency")
	}

	if !s.CreatedBy.IsUnset() {
		vals = append(vals, "created_by")
	}

	if !s.CreatedAt.IsUnset() {
		vals = append(vals, "created_at")
	}

	if !s.UpdatedAt.IsUnset() {
		vals = append(vals, "updated_at")
	}

	return vals
}

func (s AssetSetter) Overwrite(t *Asset) {
	if !s.ID.IsUnset() {
		t.ID, _ = s.ID.Get()
	}
	if !s.ParentAssetID.IsUnset() {
		t.ParentAssetID, _ = s.ParentAssetID.GetNull()
	}
	if !s.Status.IsUnset() {
		t.Status, _ = s.Status.Get()
	}
	if !s.Tag.IsUnset() {
		t.Tag, _ = s.Tag.GetNull()
	}
	if !s.Name.IsUnset() {
		t.Name, _ = s.Name.Get()
	}
	if !s.Category.IsUnset() {
		t.Category, _ = s.Category.Get()
	}
	if !s.Model.IsUnset() {
		t.Model, _ = s.Model.GetNull()
	}
	if !s.ModelNo.IsUnset() {
		t.ModelNo, _ = s.ModelNo.GetNull()
	}
	if !s.SerialNo.IsUnset() {
		t.SerialNo, _ = s.SerialNo.GetNull()
	}
	if !s.Manufacturer.IsUnset() {
		t.Manufacturer, _ = s.Manufacturer.GetNull()
	}
	if !s.Notes.IsUnset() {
		t.Notes, _ = s.Notes.GetNull()
	}
	if !s.ImageURL.IsUnset() {
		t.ImageURL, _ = s.ImageURL.GetNull()
	}
	if !s.ThumbnailURL.IsUnset() {
		t.ThumbnailURL, _ = s.ThumbnailURL.GetNull()
	}
	if !s.WarrantyUntil.IsUnset() {
		t.WarrantyUntil, _ = s.WarrantyUntil.GetNull()
	}
	if !s.CustomAttrs.IsUnset() {
		t.CustomAttrs, _ = s.CustomAttrs.GetNull()
	}
	if !s.CheckedOutTo.IsUnset() {
		t.CheckedOutTo, _ = s.CheckedOutTo.GetNull()
	}
	if !s.Location.IsUnset() {
		t.Location, _ = s.Location.GetNull()
	}
	if !s.PositionCode.IsUnset() {
		t.PositionCode, _ = s.PositionCode.GetNull()
	}
	if !s.PurchaseSupplier.IsUnset() {
		t.PurchaseSupplier, _ = s.PurchaseSupplier.GetNull()
	}
	if !s.PurchaseOrderNo.IsUnset() {
		t.PurchaseOrderNo, _ = s.PurchaseOrderNo.GetNull()
	}
	if !s.PurchaseDate.IsUnset() {
		t.PurchaseDate, _ = s.PurchaseDate.GetNull()
	}
	if !s.PurchaseAmount.IsUnset() {
		t.PurchaseAmount, _ = s.PurchaseAmount.GetNull()
	}
	if !s.PurchaseCurrency.IsUnset() {
		t.PurchaseCurrency, _ = s.PurchaseCurrency.GetNull()
	}
	if !s.CreatedBy.IsUnset() {
		t.CreatedBy, _ = s.CreatedBy.Get()
	}
	if !s.CreatedAt.IsUnset() {
		t.CreatedAt, _ = s.CreatedAt.Get()
	}
	if !s.UpdatedAt.IsUnset() {
		t.UpdatedAt, _ = s.UpdatedAt.Get()
	}
}

func (s AssetSetter) Apply(q *dialect.UpdateQuery) {
	if !s.ID.IsUnset() {
		um.Set("id").ToArg(s.ID).Apply(q)
	}
	if !s.ParentAssetID.IsUnset() {
		um.Set("parent_asset_id").ToArg(s.ParentAssetID).Apply(q)
	}
	if !s.Status.IsUnset() {
		um.Set("status").ToArg(s.Status).Apply(q)
	}
	if !s.Tag.IsUnset() {
		um.Set("tag").ToArg(s.Tag).Apply(q)
	}
	if !s.Name.IsUnset() {
		um.Set("name").ToArg(s.Name).Apply(q)
	}
	if !s.Category.IsUnset() {
		um.Set("category").ToArg(s.Category).Apply(q)
	}
	if !s.Model.IsUnset() {
		um.Set("model").ToArg(s.Model).Apply(q)
	}
	if !s.ModelNo.IsUnset() {
		um.Set("model_no").ToArg(s.ModelNo).Apply(q)
	}
	if !s.SerialNo.IsUnset() {
		um.Set("serial_no").ToArg(s.SerialNo).Apply(q)
	}
	if !s.Manufacturer.IsUnset() {
		um.Set("manufacturer").ToArg(s.Manufacturer).Apply(q)
	}
	if !s.Notes.IsUnset() {
		um.Set("notes").ToArg(s.Notes).Apply(q)
	}
	if !s.ImageURL.IsUnset() {
		um.Set("image_url").ToArg(s.ImageURL).Apply(q)
	}
	if !s.ThumbnailURL.IsUnset() {
		um.Set("thumbnail_url").ToArg(s.ThumbnailURL).Apply(q)
	}
	if !s.WarrantyUntil.IsUnset() {
		um.Set("warranty_until").ToArg(s.WarrantyUntil).Apply(q)
	}
	if !s.CustomAttrs.IsUnset() {
		um.Set("custom_attrs").ToArg(s.CustomAttrs).Apply(q)
	}
	if !s.CheckedOutTo.IsUnset() {
		um.Set("checked_out_to").ToArg(s.CheckedOutTo).Apply(q)
	}
	if !s.Location.IsUnset() {
		um.Set("location").ToArg(s.Location).Apply(q)
	}
	if !s.PositionCode.IsUnset() {
		um.Set("position_code").ToArg(s.PositionCode).Apply(q)
	}
	if !s.PurchaseSupplier.IsUnset() {
		um.Set("purchase_supplier").ToArg(s.PurchaseSupplier).Apply(q)
	}
	if !s.PurchaseOrderNo.IsUnset() {
		um.Set("purchase_order_no").ToArg(s.PurchaseOrderNo).Apply(q)
	}
	if !s.PurchaseDate.IsUnset() {
		um.Set("purchase_date").ToArg(s.PurchaseDate).Apply(q)
	}
	if !s.PurchaseAmount.IsUnset() {
		um.Set("purchase_amount").ToArg(s.PurchaseAmount).Apply(q)
	}
	if !s.PurchaseCurrency.IsUnset() {
		um.Set("purchase_currency").ToArg(s.PurchaseCurrency).Apply(q)
	}
	if !s.CreatedBy.IsUnset() {
		um.Set("created_by").ToArg(s.CreatedBy).Apply(q)
	}
	if !s.CreatedAt.IsUnset() {
		um.Set("created_at").ToArg(s.CreatedAt).Apply(q)
	}
	if !s.UpdatedAt.IsUnset() {
		um.Set("updated_at").ToArg(s.UpdatedAt).Apply(q)
	}
}

func (s AssetSetter) Insert() bob.Mod[*dialect.InsertQuery] {
	vals := make([]bob.Expression, 0, 26)
	if !s.ID.IsUnset() {
		vals = append(vals, sqlite.Arg(s.ID))
	}

	if !s.ParentAssetID.IsUnset() {
		vals = append(vals, sqlite.Arg(s.ParentAssetID))
	}

	if !s.Status.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Status))
	}

	if !s.Tag.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Tag))
	}

	if !s.Name.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Name))
	}

	if !s.Category.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Category))
	}

	if !s.Model.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Model))
	}

	if !s.ModelNo.IsUnset() {
		vals = append(vals, sqlite.Arg(s.ModelNo))
	}

	if !s.SerialNo.IsUnset() {
		vals = append(vals, sqlite.Arg(s.SerialNo))
	}

	if !s.Manufacturer.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Manufacturer))
	}

	if !s.Notes.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Notes))
	}

	if !s.ImageURL.IsUnset() {
		vals = append(vals, sqlite.Arg(s.ImageURL))
	}

	if !s.ThumbnailURL.IsUnset() {
		vals = append(vals, sqlite.Arg(s.ThumbnailURL))
	}

	if !s.WarrantyUntil.IsUnset() {
		vals = append(vals, sqlite.Arg(s.WarrantyUntil))
	}

	if !s.CustomAttrs.IsUnset() {
		vals = append(vals, sqlite.Arg(s.CustomAttrs))
	}

	if !s.CheckedOutTo.IsUnset() {
		vals = append(vals, sqlite.Arg(s.CheckedOutTo))
	}

	if !s.Location.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Location))
	}

	if !s.PositionCode.IsUnset() {
		vals = append(vals, sqlite.Arg(s.PositionCode))
	}

	if !s.PurchaseSupplier.IsUnset() {
		vals = append(vals, sqlite.Arg(s.PurchaseSupplier))
	}

	if !s.PurchaseOrderNo.IsUnset() {
		vals = append(vals, sqlite.Arg(s.PurchaseOrderNo))
	}

	if !s.PurchaseDate.IsUnset() {
		vals = append(vals, sqlite.Arg(s.PurchaseDate))
	}

	if !s.PurchaseAmount.IsUnset() {
		vals = append(vals, sqlite.Arg(s.PurchaseAmount))
	}

	if !s.PurchaseCurrency.IsUnset() {
		vals = append(vals, sqlite.Arg(s.PurchaseCurrency))
	}

	if !s.CreatedBy.IsUnset() {
		vals = append(vals, sqlite.Arg(s.CreatedBy))
	}

	if !s.CreatedAt.IsUnset() {
		vals = append(vals, sqlite.Arg(s.CreatedAt))
	}

	if !s.UpdatedAt.IsUnset() {
		vals = append(vals, sqlite.Arg(s.UpdatedAt))
	}

	return im.Values(vals...)
}

type assetColumnNames struct {
	ID               string
	ParentAssetID    string
	Status           string
	Tag              string
	Name             string
	Category         string
	Model            string
	ModelNo          string
	SerialNo         string
	Manufacturer     string
	Notes            string
	ImageURL         string
	ThumbnailURL     string
	WarrantyUntil    string
	CustomAttrs      string
	CheckedOutTo     string
	Location         string
	PositionCode     string
	PurchaseSupplier string
	PurchaseOrderNo  string
	PurchaseDate     string
	PurchaseAmount   string
	PurchaseCurrency string
	CreatedBy        string
	CreatedAt        string
	UpdatedAt        string
}

type assetRelationshipJoins[Q dialect.Joinable] struct {
	CreatedByUser       bob.Mod[Q]
	CheckedOutToUser    bob.Mod[Q]
	Tag                 bob.Mod[Q]
	ParentAsset         bob.Mod[Q]
	ReverseParentAssets bob.Mod[Q]
}

func buildassetRelationshipJoins[Q dialect.Joinable](ctx context.Context, typ string) assetRelationshipJoins[Q] {
	return assetRelationshipJoins[Q]{
		CreatedByUser:       assetsJoinCreatedByUser[Q](ctx, typ),
		CheckedOutToUser:    assetsJoinCheckedOutToUser[Q](ctx, typ),
		Tag:                 assetsJoinTag[Q](ctx, typ),
		ParentAsset:         assetsJoinParentAsset[Q](ctx, typ),
		ReverseParentAssets: assetsJoinReverseParentAssets[Q](ctx, typ),
	}
}

func assetsJoin[Q dialect.Joinable](ctx context.Context) joinSet[assetRelationshipJoins[Q]] {
	return joinSet[assetRelationshipJoins[Q]]{
		InnerJoin: buildassetRelationshipJoins[Q](ctx, clause.InnerJoin),
		LeftJoin:  buildassetRelationshipJoins[Q](ctx, clause.LeftJoin),
		RightJoin: buildassetRelationshipJoins[Q](ctx, clause.RightJoin),
	}
}

var AssetColumns = struct {
	ID               sqlite.Expression
	ParentAssetID    sqlite.Expression
	Status           sqlite.Expression
	Tag              sqlite.Expression
	Name             sqlite.Expression
	Category         sqlite.Expression
	Model            sqlite.Expression
	ModelNo          sqlite.Expression
	SerialNo         sqlite.Expression
	Manufacturer     sqlite.Expression
	Notes            sqlite.Expression
	ImageURL         sqlite.Expression
	ThumbnailURL     sqlite.Expression
	WarrantyUntil    sqlite.Expression
	CustomAttrs      sqlite.Expression
	CheckedOutTo     sqlite.Expression
	Location         sqlite.Expression
	PositionCode     sqlite.Expression
	PurchaseSupplier sqlite.Expression
	PurchaseOrderNo  sqlite.Expression
	PurchaseDate     sqlite.Expression
	PurchaseAmount   sqlite.Expression
	PurchaseCurrency sqlite.Expression
	CreatedBy        sqlite.Expression
	CreatedAt        sqlite.Expression
	UpdatedAt        sqlite.Expression
}{
	ID:               sqlite.Quote("assets", "id"),
	ParentAssetID:    sqlite.Quote("assets", "parent_asset_id"),
	Status:           sqlite.Quote("assets", "status"),
	Tag:              sqlite.Quote("assets", "tag"),
	Name:             sqlite.Quote("assets", "name"),
	Category:         sqlite.Quote("assets", "category"),
	Model:            sqlite.Quote("assets", "model"),
	ModelNo:          sqlite.Quote("assets", "model_no"),
	SerialNo:         sqlite.Quote("assets", "serial_no"),
	Manufacturer:     sqlite.Quote("assets", "manufacturer"),
	Notes:            sqlite.Quote("assets", "notes"),
	ImageURL:         sqlite.Quote("assets", "image_url"),
	ThumbnailURL:     sqlite.Quote("assets", "thumbnail_url"),
	WarrantyUntil:    sqlite.Quote("assets", "warranty_until"),
	CustomAttrs:      sqlite.Quote("assets", "custom_attrs"),
	CheckedOutTo:     sqlite.Quote("assets", "checked_out_to"),
	Location:         sqlite.Quote("assets", "location"),
	PositionCode:     sqlite.Quote("assets", "position_code"),
	PurchaseSupplier: sqlite.Quote("assets", "purchase_supplier"),
	PurchaseOrderNo:  sqlite.Quote("assets", "purchase_order_no"),
	PurchaseDate:     sqlite.Quote("assets", "purchase_date"),
	PurchaseAmount:   sqlite.Quote("assets", "purchase_amount"),
	PurchaseCurrency: sqlite.Quote("assets", "purchase_currency"),
	CreatedBy:        sqlite.Quote("assets", "created_by"),
	CreatedAt:        sqlite.Quote("assets", "created_at"),
	UpdatedAt:        sqlite.Quote("assets", "updated_at"),
}

type assetWhere[Q sqlite.Filterable] struct {
	ID               sqlite.WhereMod[Q, int64]
	ParentAssetID    sqlite.WhereNullMod[Q, int64]
	Status           sqlite.WhereMod[Q, string]
	Tag              sqlite.WhereNullMod[Q, string]
	Name             sqlite.WhereMod[Q, string]
	Category         sqlite.WhereMod[Q, string]
	Model            sqlite.WhereNullMod[Q, string]
	ModelNo          sqlite.WhereNullMod[Q, string]
	SerialNo         sqlite.WhereNullMod[Q, string]
	Manufacturer     sqlite.WhereNullMod[Q, string]
	Notes            sqlite.WhereNullMod[Q, string]
	ImageURL         sqlite.WhereNullMod[Q, string]
	ThumbnailURL     sqlite.WhereNullMod[Q, string]
	WarrantyUntil    sqlite.WhereNullMod[Q, types.SQLiteDatetime]
	CustomAttrs      sqlite.WhereNullMod[Q, types.SQLiteJSON[map[string]any]]
	CheckedOutTo     sqlite.WhereNullMod[Q, int64]
	Location         sqlite.WhereNullMod[Q, string]
	PositionCode     sqlite.WhereNullMod[Q, string]
	PurchaseSupplier sqlite.WhereNullMod[Q, string]
	PurchaseOrderNo  sqlite.WhereNullMod[Q, string]
	PurchaseDate     sqlite.WhereNullMod[Q, types.SQLiteDatetime]
	PurchaseAmount   sqlite.WhereNullMod[Q, int64]
	PurchaseCurrency sqlite.WhereNullMod[Q, string]
	CreatedBy        sqlite.WhereMod[Q, int64]
	CreatedAt        sqlite.WhereMod[Q, types.SQLiteDatetime]
	UpdatedAt        sqlite.WhereMod[Q, types.SQLiteDatetime]
}

func AssetWhere[Q sqlite.Filterable]() assetWhere[Q] {
	return assetWhere[Q]{
		ID:               sqlite.Where[Q, int64](AssetColumns.ID),
		ParentAssetID:    sqlite.WhereNull[Q, int64](AssetColumns.ParentAssetID),
		Status:           sqlite.Where[Q, string](AssetColumns.Status),
		Tag:              sqlite.WhereNull[Q, string](AssetColumns.Tag),
		Name:             sqlite.Where[Q, string](AssetColumns.Name),
		Category:         sqlite.Where[Q, string](AssetColumns.Category),
		Model:            sqlite.WhereNull[Q, string](AssetColumns.Model),
		ModelNo:          sqlite.WhereNull[Q, string](AssetColumns.ModelNo),
		SerialNo:         sqlite.WhereNull[Q, string](AssetColumns.SerialNo),
		Manufacturer:     sqlite.WhereNull[Q, string](AssetColumns.Manufacturer),
		Notes:            sqlite.WhereNull[Q, string](AssetColumns.Notes),
		ImageURL:         sqlite.WhereNull[Q, string](AssetColumns.ImageURL),
		ThumbnailURL:     sqlite.WhereNull[Q, string](AssetColumns.ThumbnailURL),
		WarrantyUntil:    sqlite.WhereNull[Q, types.SQLiteDatetime](AssetColumns.WarrantyUntil),
		CustomAttrs:      sqlite.WhereNull[Q, types.SQLiteJSON[map[string]any]](AssetColumns.CustomAttrs),
		CheckedOutTo:     sqlite.WhereNull[Q, int64](AssetColumns.CheckedOutTo),
		Location:         sqlite.WhereNull[Q, string](AssetColumns.Location),
		PositionCode:     sqlite.WhereNull[Q, string](AssetColumns.PositionCode),
		PurchaseSupplier: sqlite.WhereNull[Q, string](AssetColumns.PurchaseSupplier),
		PurchaseOrderNo:  sqlite.WhereNull[Q, string](AssetColumns.PurchaseOrderNo),
		PurchaseDate:     sqlite.WhereNull[Q, types.SQLiteDatetime](AssetColumns.PurchaseDate),
		PurchaseAmount:   sqlite.WhereNull[Q, int64](AssetColumns.PurchaseAmount),
		PurchaseCurrency: sqlite.WhereNull[Q, string](AssetColumns.PurchaseCurrency),
		CreatedBy:        sqlite.Where[Q, int64](AssetColumns.CreatedBy),
		CreatedAt:        sqlite.Where[Q, types.SQLiteDatetime](AssetColumns.CreatedAt),
		UpdatedAt:        sqlite.Where[Q, types.SQLiteDatetime](AssetColumns.UpdatedAt),
	}
}

// FindAsset retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindAsset(ctx context.Context, exec bob.Executor, IDPK int64, cols ...string) (*Asset, error) {
	if len(cols) == 0 {
		return Assets.Query(
			ctx, exec,
			SelectWhere.Assets.ID.EQ(IDPK),
		).One()
	}

	return Assets.Query(
		ctx, exec,
		SelectWhere.Assets.ID.EQ(IDPK),
		sm.Columns(Assets.Columns().Only(cols...)),
	).One()
}

// AssetExists checks the presence of a single record by primary key
func AssetExists(ctx context.Context, exec bob.Executor, IDPK int64) (bool, error) {
	return Assets.Query(
		ctx, exec,
		SelectWhere.Assets.ID.EQ(IDPK),
	).Exists()
}

// PrimaryKeyVals returns the primary key values of the Asset
func (o *Asset) PrimaryKeyVals() bob.Expression {
	return sqlite.Arg(o.ID)
}

// Update uses an executor to update the Asset
func (o *Asset) Update(ctx context.Context, exec bob.Executor, s *AssetSetter) error {
	return Assets.Update(ctx, exec, s, o)
}

// Delete deletes a single Asset record with an executor
func (o *Asset) Delete(ctx context.Context, exec bob.Executor) error {
	return Assets.Delete(ctx, exec, o)
}

// Reload refreshes the Asset using the executor
func (o *Asset) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Assets.Query(
		ctx, exec,
		SelectWhere.Assets.ID.EQ(o.ID),
	).One()
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

func (o AssetSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals AssetSetter) error {
	return Assets.Update(ctx, exec, &vals, o...)
}

func (o AssetSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	return Assets.Delete(ctx, exec, o...)
}

func (o AssetSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	IDPK := make([]int64, len(o))

	for i, o := range o {
		IDPK[i] = o.ID
	}

	mods = append(mods,
		SelectWhere.Assets.ID.In(IDPK...),
	)

	o2, err := Assets.Query(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			*old = *new
			break
		}
	}

	return nil
}

func assetsJoinCreatedByUser[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Users.Name(ctx)).On(
			UserColumns.ID.EQ(AssetColumns.CreatedBy),
		),
	}
}
func assetsJoinCheckedOutToUser[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Users.Name(ctx)).On(
			UserColumns.ID.EQ(AssetColumns.CheckedOutTo),
		),
	}
}
func assetsJoinTag[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Tags.Name(ctx)).On(
			TagColumns.Tag.EQ(AssetColumns.Tag),
		),
	}
}
func assetsJoinParentAsset[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Assets.Name(ctx)).On(
			AssetColumns.ID.EQ(AssetColumns.ParentAssetID),
		),
	}
}
func assetsJoinReverseParentAssets[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Assets.Name(ctx)).On(
			AssetColumns.ParentAssetID.EQ(AssetColumns.ID),
		),
	}
}

// CreatedByUser starts a query for related objects on users
func (o *Asset) CreatedByUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(ctx, exec, append(mods,
		sm.Where(UserColumns.ID.EQ(sqlite.Arg(o.CreatedBy))),
	)...)
}

func (os AssetSlice) CreatedByUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = sqlite.ArgGroup(o.CreatedBy)
	}

	return Users.Query(ctx, exec, append(mods,
		sm.Where(sqlite.Group(UserColumns.ID).In(PKArgs...)),
	)...)
}

// CheckedOutToUser starts a query for related objects on users
func (o *Asset) CheckedOutToUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(ctx, exec, append(mods,
		sm.Where(UserColumns.ID.EQ(sqlite.Arg(o.CheckedOutTo))),
	)...)
}

func (os AssetSlice) CheckedOutToUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = sqlite.ArgGroup(o.CheckedOutTo)
	}

	return Users.Query(ctx, exec, append(mods,
		sm.Where(sqlite.Group(UserColumns.ID).In(PKArgs...)),
	)...)
}

// Tag starts a query for related objects on tags
func (o *Asset) RelatedTag(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TagsQuery {
	return Tags.Query(ctx, exec, append(mods,
		sm.Where(TagColumns.Tag.EQ(sqlite.Arg(o.Tag))),
	)...)
}

func (os AssetSlice) RelatedTag(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TagsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = sqlite.ArgGroup(o.Tag)
	}

	return Tags.Query(ctx, exec, append(mods,
		sm.Where(sqlite.Group(TagColumns.Tag).In(PKArgs...)),
	)...)
}

// ParentAsset starts a query for related objects on assets
func (o *Asset) ParentAsset(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetsQuery {
	return Assets.Query(ctx, exec, append(mods,
		sm.Where(AssetColumns.ID.EQ(sqlite.Arg(o.ParentAssetID))),
	)...)
}

func (os AssetSlice) ParentAsset(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = sqlite.ArgGroup(o.ParentAssetID)
	}

	return Assets.Query(ctx, exec, append(mods,
		sm.Where(sqlite.Group(AssetColumns.ID).In(PKArgs...)),
	)...)
}

// ReverseParentAssets starts a query for related objects on assets
func (o *Asset) ReverseParentAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetsQuery {
	return Assets.Query(ctx, exec, append(mods,
		sm.Where(AssetColumns.ParentAssetID.EQ(sqlite.Arg(o.ID))),
	)...)
}

func (os AssetSlice) ReverseParentAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = sqlite.ArgGroup(o.ID)
	}

	return Assets.Query(ctx, exec, append(mods,
		sm.Where(sqlite.Group(AssetColumns.ParentAssetID).In(PKArgs...)),
	)...)
}

func (o *Asset) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "CreatedByUser":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("asset cannot load %T as %q", retrieved, name)
		}

		o.R.CreatedByUser = rel

		return nil
	case "CheckedOutToUser":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("asset cannot load %T as %q", retrieved, name)
		}

		o.R.CheckedOutToUser = rel

		return nil
	case "Tag":
		rel, ok := retrieved.(*Tag)
		if !ok {
			return fmt.Errorf("asset cannot load %T as %q", retrieved, name)
		}

		o.R.Tag = rel

		return nil
	case "ParentAsset":
		rel, ok := retrieved.(*Asset)
		if !ok {
			return fmt.Errorf("asset cannot load %T as %q", retrieved, name)
		}

		o.R.ParentAsset = rel

		return nil
	case "ReverseParentAssets":
		rels, ok := retrieved.(AssetSlice)
		if !ok {
			return fmt.Errorf("asset cannot load %T as %q", retrieved, name)
		}

		o.R.ReverseParentAssets = rels

		return nil
	default:
		return fmt.Errorf("asset has no relationship %q", name)
	}
}

func PreloadAssetCreatedByUser(opts ...sqlite.PreloadOption) sqlite.Preloader {
	return sqlite.Preload[*User, UserSlice](orm.Relationship{
		Name: "CreatedByUser",
		Sides: []orm.RelSide{
			{
				From: "assets",
				To:   TableNames.Users,
				ToExpr: func(ctx context.Context) bob.Expression {
					return Users.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Assets.CreatedBy,
				},
				ToColumns: []string{
					ColumnNames.Users.ID,
				},
			},
		},
	}, Users.Columns().Names(), opts...)
}

func ThenLoadAssetCreatedByUser(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadAssetCreatedByUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load AssetCreatedByUser", retrieved)
		}

		err := loader.LoadAssetCreatedByUser(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadAssetCreatedByUser loads the asset's CreatedByUser into the .R struct
func (o *Asset) LoadAssetCreatedByUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CreatedByUser = nil

	related, err := o.CreatedByUser(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	o.R.CreatedByUser = related
	return nil
}

// LoadAssetCreatedByUser loads the asset's CreatedByUser into the .R struct
func (os AssetSlice) LoadAssetCreatedByUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.CreatedByUser(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range users {
			if o.CreatedBy != rel.ID {
				continue
			}

			o.R.CreatedByUser = rel
			break
		}
	}

	return nil
}

func PreloadAssetCheckedOutToUser(opts ...sqlite.PreloadOption) sqlite.Preloader {
	return sqlite.Preload[*User, UserSlice](orm.Relationship{
		Name: "CheckedOutToUser",
		Sides: []orm.RelSide{
			{
				From: "assets",
				To:   TableNames.Users,
				ToExpr: func(ctx context.Context) bob.Expression {
					return Users.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Assets.CheckedOutTo,
				},
				ToColumns: []string{
					ColumnNames.Users.ID,
				},
			},
		},
	}, Users.Columns().Names(), opts...)
}

func ThenLoadAssetCheckedOutToUser(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadAssetCheckedOutToUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load AssetCheckedOutToUser", retrieved)
		}

		err := loader.LoadAssetCheckedOutToUser(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadAssetCheckedOutToUser loads the asset's CheckedOutToUser into the .R struct
func (o *Asset) LoadAssetCheckedOutToUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CheckedOutToUser = nil

	related, err := o.CheckedOutToUser(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	o.R.CheckedOutToUser = related
	return nil
}

// LoadAssetCheckedOutToUser loads the asset's CheckedOutToUser into the .R struct
func (os AssetSlice) LoadAssetCheckedOutToUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.CheckedOutToUser(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range users {
			if o.CheckedOutTo.GetOrZero() != rel.ID {
				continue
			}

			o.R.CheckedOutToUser = rel
			break
		}
	}

	return nil
}

func PreloadAssetTag(opts ...sqlite.PreloadOption) sqlite.Preloader {
	return sqlite.Preload[*Tag, TagSlice](orm.Relationship{
		Name: "Tag",
		Sides: []orm.RelSide{
			{
				From: "assets",
				To:   TableNames.Tags,
				ToExpr: func(ctx context.Context) bob.Expression {
					return Tags.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Assets.Tag,
				},
				ToColumns: []string{
					ColumnNames.Tags.Tag,
				},
			},
		},
	}, Tags.Columns().Names(), opts...)
}

func ThenLoadAssetTag(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadAssetTag(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load AssetTag", retrieved)
		}

		err := loader.LoadAssetTag(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadAssetTag loads the asset's Tag into the .R struct
func (o *Asset) LoadAssetTag(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Tag = nil

	related, err := o.RelatedTag(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	o.R.Tag = related
	return nil
}

// LoadAssetTag loads the asset's Tag into the .R struct
func (os AssetSlice) LoadAssetTag(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	tags, err := os.RelatedTag(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range tags {
			if o.Tag.GetOrZero() != rel.Tag {
				continue
			}

			o.R.Tag = rel
			break
		}
	}

	return nil
}

func PreloadAssetParentAsset(opts ...sqlite.PreloadOption) sqlite.Preloader {
	return sqlite.Preload[*Asset, AssetSlice](orm.Relationship{
		Name: "ParentAsset",
		Sides: []orm.RelSide{
			{
				From: "assets",
				To:   TableNames.Assets,
				ToExpr: func(ctx context.Context) bob.Expression {
					return Assets.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.Assets.ParentAssetID,
				},
				ToColumns: []string{
					ColumnNames.Assets.ID,
				},
			},
		},
	}, Assets.Columns().Names(), opts...)
}

func ThenLoadAssetParentAsset(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadAssetParentAsset(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load AssetParentAsset", retrieved)
		}

		err := loader.LoadAssetParentAsset(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadAssetParentAsset loads the asset's ParentAsset into the .R struct
func (o *Asset) LoadAssetParentAsset(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ParentAsset = nil

	related, err := o.ParentAsset(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	o.R.ParentAsset = related
	return nil
}

// LoadAssetParentAsset loads the asset's ParentAsset into the .R struct
func (os AssetSlice) LoadAssetParentAsset(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	assets, err := os.ParentAsset(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range assets {
			if o.ParentAssetID.GetOrZero() != rel.ID {
				continue
			}

			o.R.ParentAsset = rel
			break
		}
	}

	return nil
}

func ThenLoadAssetReverseParentAssets(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadAssetReverseParentAssets(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load AssetReverseParentAssets", retrieved)
		}

		err := loader.LoadAssetReverseParentAssets(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadAssetReverseParentAssets loads the asset's ReverseParentAssets into the .R struct
func (o *Asset) LoadAssetReverseParentAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ReverseParentAssets = nil

	related, err := o.ReverseParentAssets(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	o.R.ReverseParentAssets = related
	return nil
}

// LoadAssetReverseParentAssets loads the asset's ReverseParentAssets into the .R struct
func (os AssetSlice) LoadAssetReverseParentAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	assets, err := os.ReverseParentAssets(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.ReverseParentAssets = nil
	}

	for _, o := range os {
		for _, rel := range assets {
			if o.ID != rel.ParentAssetID.GetOrZero() {
				continue
			}

			o.R.ReverseParentAssets = append(o.R.ReverseParentAssets, rel)
		}
	}

	return nil
}

func attachAssetCreatedByUser0(ctx context.Context, exec bob.Executor, asset0 *Asset, user1 *User) error {
	setter := &AssetSetter{
		CreatedBy: omit.From(user1.ID),
	}

	err := Assets.Update(ctx, exec, setter, asset0)
	if err != nil {
		return fmt.Errorf("attachAssetCreatedByUser0: %w", err)
	}

	return nil
}

func (asset0 *Asset) InsertCreatedByUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	user1, err := Users.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	err = attachAssetCreatedByUser0(ctx, exec, asset0, user1)
	if err != nil {
		return err
	}

	asset0.R.CreatedByUser = user1

	return nil
}

func (asset0 *Asset) AttachCreatedByUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	err = attachAssetCreatedByUser0(ctx, exec, asset0, user1)
	if err != nil {
		return err
	}

	asset0.R.CreatedByUser = user1

	return nil
}

func attachAssetCheckedOutToUser0(ctx context.Context, exec bob.Executor, asset0 *Asset, user1 *User) error {
	setter := &AssetSetter{
		CheckedOutTo: omitnull.From(user1.ID),
	}

	err := Assets.Update(ctx, exec, setter, asset0)
	if err != nil {
		return fmt.Errorf("attachAssetCheckedOutToUser0: %w", err)
	}

	return nil
}

func (asset0 *Asset) InsertCheckedOutToUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	user1, err := Users.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	err = attachAssetCheckedOutToUser0(ctx, exec, asset0, user1)
	if err != nil {
		return err
	}

	asset0.R.CheckedOutToUser = user1

	return nil
}

func (asset0 *Asset) AttachCheckedOutToUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	err = attachAssetCheckedOutToUser0(ctx, exec, asset0, user1)
	if err != nil {
		return err
	}

	asset0.R.CheckedOutToUser = user1

	return nil
}

func attachAssetTag0(ctx context.Context, exec bob.Executor, asset0 *Asset, tag1 *Tag) error {
	setter := &AssetSetter{
		Tag: omitnull.From(tag1.Tag),
	}

	err := Assets.Update(ctx, exec, setter, asset0)
	if err != nil {
		return fmt.Errorf("attachAssetTag0: %w", err)
	}

	return nil
}

func (asset0 *Asset) InsertTag(ctx context.Context, exec bob.Executor, related *TagSetter) error {
	tag1, err := Tags.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	err = attachAssetTag0(ctx, exec, asset0, tag1)
	if err != nil {
		return err
	}

	asset0.R.Tag = tag1

	return nil
}

func (asset0 *Asset) AttachTag(ctx context.Context, exec bob.Executor, tag1 *Tag) error {
	var err error

	err = attachAssetTag0(ctx, exec, asset0, tag1)
	if err != nil {
		return err
	}

	asset0.R.Tag = tag1

	return nil
}

func attachAssetParentAsset0(ctx context.Context, exec bob.Executor, asset0 *Asset, asset1 *Asset) error {
	setter := &AssetSetter{
		ParentAssetID: omitnull.From(asset1.ID),
	}

	err := Assets.Update(ctx, exec, setter, asset0)
	if err != nil {
		return fmt.Errorf("attachAssetParentAsset0: %w", err)
	}

	return nil
}

func (asset0 *Asset) InsertParentAsset(ctx context.Context, exec bob.Executor, related *AssetSetter) error {
	asset1, err := Assets.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	err = attachAssetParentAsset0(ctx, exec, asset0, asset1)
	if err != nil {
		return err
	}

	asset0.R.ParentAsset = asset1

	return nil
}

func (asset0 *Asset) AttachParentAsset(ctx context.Context, exec bob.Executor, asset1 *Asset) error {
	var err error

	err = attachAssetParentAsset0(ctx, exec, asset0, asset1)
	if err != nil {
		return err
	}

	asset0.R.ParentAsset = asset1

	return nil
}

func insertAssetReverseParentAssets0(ctx context.Context, exec bob.Executor, assets1 []*AssetSetter, asset0 *Asset) (AssetSlice, error) {
	for _, asset1 := range assets1 {
		asset1.ParentAssetID = omitnull.From(asset0.ID)
	}

	ret, err := Assets.InsertMany(ctx, exec, assets1...)
	if err != nil {
		return ret, fmt.Errorf("insertAssetReverseParentAssets0: %w", err)
	}

	return ret, nil
}

func attachAssetReverseParentAssets0(ctx context.Context, exec bob.Executor, assets1 AssetSlice, asset0 *Asset) error {
	setter := &AssetSetter{
		ParentAssetID: omitnull.From(asset0.ID),
	}

	err := Assets.Update(ctx, exec, setter, assets1...)
	if err != nil {
		return fmt.Errorf("attachAssetReverseParentAssets0: %w", err)
	}

	return nil
}

func (asset0 *Asset) InsertReverseParentAssets(ctx context.Context, exec bob.Executor, related ...*AssetSetter) error {
	if len(related) == 0 {
		return nil
	}

	asset1, err := insertAssetReverseParentAssets0(ctx, exec, related, asset0)
	if err != nil {
		return err
	}

	asset0.R.ReverseParentAssets = append(asset0.R.ReverseParentAssets, asset1...)

	return nil
}

func (asset0 *Asset) AttachReverseParentAssets(ctx context.Context, exec bob.Executor, related ...*Asset) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	asset1 := AssetSlice(related)

	err = attachAssetReverseParentAssets0(ctx, exec, asset1, asset0)
	if err != nil {
		return err
	}

	asset0.R.ReverseParentAssets = append(asset0.R.ReverseParentAssets, asset1...)

	return nil
}
