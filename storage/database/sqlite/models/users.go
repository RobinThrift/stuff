// Code generated by BobGen sqlite v0.22.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/RobinThrift/stuff/storage/database/sqlite/types"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/sqlite"
	"github.com/stephenafamo/bob/dialect/sqlite/dialect"
	"github.com/stephenafamo/bob/dialect/sqlite/im"
	"github.com/stephenafamo/bob/dialect/sqlite/sm"
	"github.com/stephenafamo/bob/dialect/sqlite/um"
	"github.com/stephenafamo/bob/mods"
)

// User is an object representing the database table.
type User struct {
	ID          int64                `db:"id,pk" `
	Username    string               `db:"username" `
	DisplayName string               `db:"display_name" `
	IsAdmin     bool                 `db:"is_admin" `
	AuthRef     string               `db:"auth_ref" `
	CreatedAt   types.SQLiteDatetime `db:"created_at" `
	UpdatedAt   types.SQLiteDatetime `db:"updated_at" `

	R userR `db:"-" `
}

// UserSlice is an alias for a slice of pointers to User.
// This should almost always be used instead of []*User.
type UserSlice []*User

// Users contains methods to work with the users table
var Users = sqlite.NewTablex[*User, UserSlice, *UserSetter]("", "users")

// UsersQuery is a query on the users table
type UsersQuery = *sqlite.ViewQuery[*User, UserSlice]

// UsersStmt is a prepared statment on users
type UsersStmt = bob.QueryStmt[*User, UserSlice]

// userR is where relationships are stored.
type userR struct {
	CreatedByAssetFiles AssetFileSlice // fk_asset_files_0
	CreatedByAssetParts AssetPartSlice // fk_asset_parts_0
	CreatedByAssets     AssetSlice     // fk_assets_0
	CheckedOutToAssets  AssetSlice     // fk_assets_1
}

// UserSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type UserSetter struct {
	ID          omit.Val[int64]                `db:"id,pk"`
	Username    omit.Val[string]               `db:"username"`
	DisplayName omit.Val[string]               `db:"display_name"`
	IsAdmin     omit.Val[bool]                 `db:"is_admin"`
	AuthRef     omit.Val[string]               `db:"auth_ref"`
	CreatedAt   omit.Val[types.SQLiteDatetime] `db:"created_at"`
	UpdatedAt   omit.Val[types.SQLiteDatetime] `db:"updated_at"`
}

func (s UserSetter) SetColumns() []string {
	vals := make([]string, 0, 7)
	if !s.ID.IsUnset() {
		vals = append(vals, "id")
	}

	if !s.Username.IsUnset() {
		vals = append(vals, "username")
	}

	if !s.DisplayName.IsUnset() {
		vals = append(vals, "display_name")
	}

	if !s.IsAdmin.IsUnset() {
		vals = append(vals, "is_admin")
	}

	if !s.AuthRef.IsUnset() {
		vals = append(vals, "auth_ref")
	}

	if !s.CreatedAt.IsUnset() {
		vals = append(vals, "created_at")
	}

	if !s.UpdatedAt.IsUnset() {
		vals = append(vals, "updated_at")
	}

	return vals
}

func (s UserSetter) Overwrite(t *User) {
	if !s.ID.IsUnset() {
		t.ID, _ = s.ID.Get()
	}
	if !s.Username.IsUnset() {
		t.Username, _ = s.Username.Get()
	}
	if !s.DisplayName.IsUnset() {
		t.DisplayName, _ = s.DisplayName.Get()
	}
	if !s.IsAdmin.IsUnset() {
		t.IsAdmin, _ = s.IsAdmin.Get()
	}
	if !s.AuthRef.IsUnset() {
		t.AuthRef, _ = s.AuthRef.Get()
	}
	if !s.CreatedAt.IsUnset() {
		t.CreatedAt, _ = s.CreatedAt.Get()
	}
	if !s.UpdatedAt.IsUnset() {
		t.UpdatedAt, _ = s.UpdatedAt.Get()
	}
}

func (s UserSetter) Apply(q *dialect.UpdateQuery) {
	if !s.ID.IsUnset() {
		um.Set("id").ToArg(s.ID).Apply(q)
	}
	if !s.Username.IsUnset() {
		um.Set("username").ToArg(s.Username).Apply(q)
	}
	if !s.DisplayName.IsUnset() {
		um.Set("display_name").ToArg(s.DisplayName).Apply(q)
	}
	if !s.IsAdmin.IsUnset() {
		um.Set("is_admin").ToArg(s.IsAdmin).Apply(q)
	}
	if !s.AuthRef.IsUnset() {
		um.Set("auth_ref").ToArg(s.AuthRef).Apply(q)
	}
	if !s.CreatedAt.IsUnset() {
		um.Set("created_at").ToArg(s.CreatedAt).Apply(q)
	}
	if !s.UpdatedAt.IsUnset() {
		um.Set("updated_at").ToArg(s.UpdatedAt).Apply(q)
	}
}

func (s UserSetter) Insert() bob.Mod[*dialect.InsertQuery] {
	vals := make([]bob.Expression, 0, 7)
	if !s.ID.IsUnset() {
		vals = append(vals, sqlite.Arg(s.ID))
	}

	if !s.Username.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Username))
	}

	if !s.DisplayName.IsUnset() {
		vals = append(vals, sqlite.Arg(s.DisplayName))
	}

	if !s.IsAdmin.IsUnset() {
		vals = append(vals, sqlite.Arg(s.IsAdmin))
	}

	if !s.AuthRef.IsUnset() {
		vals = append(vals, sqlite.Arg(s.AuthRef))
	}

	if !s.CreatedAt.IsUnset() {
		vals = append(vals, sqlite.Arg(s.CreatedAt))
	}

	if !s.UpdatedAt.IsUnset() {
		vals = append(vals, sqlite.Arg(s.UpdatedAt))
	}

	return im.Values(vals...)
}

type userColumnNames struct {
	ID          string
	Username    string
	DisplayName string
	IsAdmin     string
	AuthRef     string
	CreatedAt   string
	UpdatedAt   string
}

type userRelationshipJoins[Q dialect.Joinable] struct {
	CreatedByAssetFiles bob.Mod[Q]
	CreatedByAssetParts bob.Mod[Q]
	CreatedByAssets     bob.Mod[Q]
	CheckedOutToAssets  bob.Mod[Q]
}

func builduserRelationshipJoins[Q dialect.Joinable](ctx context.Context, typ string) userRelationshipJoins[Q] {
	return userRelationshipJoins[Q]{
		CreatedByAssetFiles: usersJoinCreatedByAssetFiles[Q](ctx, typ),
		CreatedByAssetParts: usersJoinCreatedByAssetParts[Q](ctx, typ),
		CreatedByAssets:     usersJoinCreatedByAssets[Q](ctx, typ),
		CheckedOutToAssets:  usersJoinCheckedOutToAssets[Q](ctx, typ),
	}
}

func usersJoin[Q dialect.Joinable](ctx context.Context) joinSet[userRelationshipJoins[Q]] {
	return joinSet[userRelationshipJoins[Q]]{
		InnerJoin: builduserRelationshipJoins[Q](ctx, clause.InnerJoin),
		LeftJoin:  builduserRelationshipJoins[Q](ctx, clause.LeftJoin),
		RightJoin: builduserRelationshipJoins[Q](ctx, clause.RightJoin),
	}
}

var UserColumns = struct {
	ID          sqlite.Expression
	Username    sqlite.Expression
	DisplayName sqlite.Expression
	IsAdmin     sqlite.Expression
	AuthRef     sqlite.Expression
	CreatedAt   sqlite.Expression
	UpdatedAt   sqlite.Expression
}{
	ID:          sqlite.Quote("users", "id"),
	Username:    sqlite.Quote("users", "username"),
	DisplayName: sqlite.Quote("users", "display_name"),
	IsAdmin:     sqlite.Quote("users", "is_admin"),
	AuthRef:     sqlite.Quote("users", "auth_ref"),
	CreatedAt:   sqlite.Quote("users", "created_at"),
	UpdatedAt:   sqlite.Quote("users", "updated_at"),
}

type userWhere[Q sqlite.Filterable] struct {
	ID          sqlite.WhereMod[Q, int64]
	Username    sqlite.WhereMod[Q, string]
	DisplayName sqlite.WhereMod[Q, string]
	IsAdmin     sqlite.WhereMod[Q, bool]
	AuthRef     sqlite.WhereMod[Q, string]
	CreatedAt   sqlite.WhereMod[Q, types.SQLiteDatetime]
	UpdatedAt   sqlite.WhereMod[Q, types.SQLiteDatetime]
}

func UserWhere[Q sqlite.Filterable]() userWhere[Q] {
	return userWhere[Q]{
		ID:          sqlite.Where[Q, int64](UserColumns.ID),
		Username:    sqlite.Where[Q, string](UserColumns.Username),
		DisplayName: sqlite.Where[Q, string](UserColumns.DisplayName),
		IsAdmin:     sqlite.Where[Q, bool](UserColumns.IsAdmin),
		AuthRef:     sqlite.Where[Q, string](UserColumns.AuthRef),
		CreatedAt:   sqlite.Where[Q, types.SQLiteDatetime](UserColumns.CreatedAt),
		UpdatedAt:   sqlite.Where[Q, types.SQLiteDatetime](UserColumns.UpdatedAt),
	}
}

// FindUser retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindUser(ctx context.Context, exec bob.Executor, IDPK int64, cols ...string) (*User, error) {
	if len(cols) == 0 {
		return Users.Query(
			ctx, exec,
			SelectWhere.Users.ID.EQ(IDPK),
		).One()
	}

	return Users.Query(
		ctx, exec,
		SelectWhere.Users.ID.EQ(IDPK),
		sm.Columns(Users.Columns().Only(cols...)),
	).One()
}

// UserExists checks the presence of a single record by primary key
func UserExists(ctx context.Context, exec bob.Executor, IDPK int64) (bool, error) {
	return Users.Query(
		ctx, exec,
		SelectWhere.Users.ID.EQ(IDPK),
	).Exists()
}

// PrimaryKeyVals returns the primary key values of the User
func (o *User) PrimaryKeyVals() bob.Expression {
	return sqlite.Arg(o.ID)
}

// Update uses an executor to update the User
func (o *User) Update(ctx context.Context, exec bob.Executor, s *UserSetter) error {
	return Users.Update(ctx, exec, s, o)
}

// Delete deletes a single User record with an executor
func (o *User) Delete(ctx context.Context, exec bob.Executor) error {
	return Users.Delete(ctx, exec, o)
}

// Reload refreshes the User using the executor
func (o *User) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Users.Query(
		ctx, exec,
		SelectWhere.Users.ID.EQ(o.ID),
	).One()
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

func (o UserSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals UserSetter) error {
	return Users.Update(ctx, exec, &vals, o...)
}

func (o UserSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	return Users.Delete(ctx, exec, o...)
}

func (o UserSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	IDPK := make([]int64, len(o))

	for i, o := range o {
		IDPK[i] = o.ID
	}

	mods = append(mods,
		SelectWhere.Users.ID.In(IDPK...),
	)

	o2, err := Users.Query(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			*old = *new
			break
		}
	}

	return nil
}

func usersJoinCreatedByAssetFiles[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, AssetFiles.Name(ctx)).On(
			AssetFileColumns.CreatedBy.EQ(UserColumns.ID),
		),
	}
}
func usersJoinCreatedByAssetParts[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, AssetParts.Name(ctx)).On(
			AssetPartColumns.CreatedBy.EQ(UserColumns.ID),
		),
	}
}
func usersJoinCreatedByAssets[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Assets.Name(ctx)).On(
			AssetColumns.CreatedBy.EQ(UserColumns.ID),
		),
	}
}
func usersJoinCheckedOutToAssets[Q dialect.Joinable](ctx context.Context, typ string) bob.Mod[Q] {
	return mods.QueryMods[Q]{
		dialect.Join[Q](typ, Assets.Name(ctx)).On(
			AssetColumns.CheckedOutTo.EQ(UserColumns.ID),
		),
	}
}

// CreatedByAssetFiles starts a query for related objects on asset_files
func (o *User) CreatedByAssetFiles(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetFilesQuery {
	return AssetFiles.Query(ctx, exec, append(mods,
		sm.Where(AssetFileColumns.CreatedBy.EQ(sqlite.Arg(o.ID))),
	)...)
}

func (os UserSlice) CreatedByAssetFiles(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetFilesQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = sqlite.ArgGroup(o.ID)
	}

	return AssetFiles.Query(ctx, exec, append(mods,
		sm.Where(sqlite.Group(AssetFileColumns.CreatedBy).In(PKArgs...)),
	)...)
}

// CreatedByAssetParts starts a query for related objects on asset_parts
func (o *User) CreatedByAssetParts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetPartsQuery {
	return AssetParts.Query(ctx, exec, append(mods,
		sm.Where(AssetPartColumns.CreatedBy.EQ(sqlite.Arg(o.ID))),
	)...)
}

func (os UserSlice) CreatedByAssetParts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetPartsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = sqlite.ArgGroup(o.ID)
	}

	return AssetParts.Query(ctx, exec, append(mods,
		sm.Where(sqlite.Group(AssetPartColumns.CreatedBy).In(PKArgs...)),
	)...)
}

// CreatedByAssets starts a query for related objects on assets
func (o *User) CreatedByAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetsQuery {
	return Assets.Query(ctx, exec, append(mods,
		sm.Where(AssetColumns.CreatedBy.EQ(sqlite.Arg(o.ID))),
	)...)
}

func (os UserSlice) CreatedByAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = sqlite.ArgGroup(o.ID)
	}

	return Assets.Query(ctx, exec, append(mods,
		sm.Where(sqlite.Group(AssetColumns.CreatedBy).In(PKArgs...)),
	)...)
}

// CheckedOutToAssets starts a query for related objects on assets
func (o *User) CheckedOutToAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetsQuery {
	return Assets.Query(ctx, exec, append(mods,
		sm.Where(AssetColumns.CheckedOutTo.EQ(sqlite.Arg(o.ID))),
	)...)
}

func (os UserSlice) CheckedOutToAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) AssetsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = sqlite.ArgGroup(o.ID)
	}

	return Assets.Query(ctx, exec, append(mods,
		sm.Where(sqlite.Group(AssetColumns.CheckedOutTo).In(PKArgs...)),
	)...)
}

func (o *User) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "CreatedByAssetFiles":
		rels, ok := retrieved.(AssetFileSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.CreatedByAssetFiles = rels

		return nil
	case "CreatedByAssetParts":
		rels, ok := retrieved.(AssetPartSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.CreatedByAssetParts = rels

		return nil
	case "CreatedByAssets":
		rels, ok := retrieved.(AssetSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.CreatedByAssets = rels

		return nil
	case "CheckedOutToAssets":
		rels, ok := retrieved.(AssetSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.CheckedOutToAssets = rels

		return nil
	default:
		return fmt.Errorf("user has no relationship %q", name)
	}
}

func ThenLoadUserCreatedByAssetFiles(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadUserCreatedByAssetFiles(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load UserCreatedByAssetFiles", retrieved)
		}

		err := loader.LoadUserCreatedByAssetFiles(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadUserCreatedByAssetFiles loads the user's CreatedByAssetFiles into the .R struct
func (o *User) LoadUserCreatedByAssetFiles(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CreatedByAssetFiles = nil

	related, err := o.CreatedByAssetFiles(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	o.R.CreatedByAssetFiles = related
	return nil
}

// LoadUserCreatedByAssetFiles loads the user's CreatedByAssetFiles into the .R struct
func (os UserSlice) LoadUserCreatedByAssetFiles(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	assetFiles, err := os.CreatedByAssetFiles(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.CreatedByAssetFiles = nil
	}

	for _, o := range os {
		for _, rel := range assetFiles {
			if o.ID != rel.CreatedBy {
				continue
			}

			o.R.CreatedByAssetFiles = append(o.R.CreatedByAssetFiles, rel)
		}
	}

	return nil
}

func ThenLoadUserCreatedByAssetParts(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadUserCreatedByAssetParts(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load UserCreatedByAssetParts", retrieved)
		}

		err := loader.LoadUserCreatedByAssetParts(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadUserCreatedByAssetParts loads the user's CreatedByAssetParts into the .R struct
func (o *User) LoadUserCreatedByAssetParts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CreatedByAssetParts = nil

	related, err := o.CreatedByAssetParts(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	o.R.CreatedByAssetParts = related
	return nil
}

// LoadUserCreatedByAssetParts loads the user's CreatedByAssetParts into the .R struct
func (os UserSlice) LoadUserCreatedByAssetParts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	assetParts, err := os.CreatedByAssetParts(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.CreatedByAssetParts = nil
	}

	for _, o := range os {
		for _, rel := range assetParts {
			if o.ID != rel.CreatedBy {
				continue
			}

			o.R.CreatedByAssetParts = append(o.R.CreatedByAssetParts, rel)
		}
	}

	return nil
}

func ThenLoadUserCreatedByAssets(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadUserCreatedByAssets(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load UserCreatedByAssets", retrieved)
		}

		err := loader.LoadUserCreatedByAssets(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadUserCreatedByAssets loads the user's CreatedByAssets into the .R struct
func (o *User) LoadUserCreatedByAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CreatedByAssets = nil

	related, err := o.CreatedByAssets(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	o.R.CreatedByAssets = related
	return nil
}

// LoadUserCreatedByAssets loads the user's CreatedByAssets into the .R struct
func (os UserSlice) LoadUserCreatedByAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	assets, err := os.CreatedByAssets(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.CreatedByAssets = nil
	}

	for _, o := range os {
		for _, rel := range assets {
			if o.ID != rel.CreatedBy {
				continue
			}

			o.R.CreatedByAssets = append(o.R.CreatedByAssets, rel)
		}
	}

	return nil
}

func ThenLoadUserCheckedOutToAssets(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadUserCheckedOutToAssets(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load UserCheckedOutToAssets", retrieved)
		}

		err := loader.LoadUserCheckedOutToAssets(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadUserCheckedOutToAssets loads the user's CheckedOutToAssets into the .R struct
func (o *User) LoadUserCheckedOutToAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CheckedOutToAssets = nil

	related, err := o.CheckedOutToAssets(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	o.R.CheckedOutToAssets = related
	return nil
}

// LoadUserCheckedOutToAssets loads the user's CheckedOutToAssets into the .R struct
func (os UserSlice) LoadUserCheckedOutToAssets(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	assets, err := os.CheckedOutToAssets(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.CheckedOutToAssets = nil
	}

	for _, o := range os {
		for _, rel := range assets {
			if o.ID != rel.CheckedOutTo.GetOrZero() {
				continue
			}

			o.R.CheckedOutToAssets = append(o.R.CheckedOutToAssets, rel)
		}
	}

	return nil
}

func insertUserCreatedByAssetFiles0(ctx context.Context, exec bob.Executor, assetFiles1 []*AssetFileSetter, user0 *User) (AssetFileSlice, error) {
	for _, assetFile1 := range assetFiles1 {
		assetFile1.CreatedBy = omit.From(user0.ID)
	}

	ret, err := AssetFiles.InsertMany(ctx, exec, assetFiles1...)
	if err != nil {
		return ret, fmt.Errorf("insertUserCreatedByAssetFiles0: %w", err)
	}

	return ret, nil
}

func attachUserCreatedByAssetFiles0(ctx context.Context, exec bob.Executor, assetFiles1 AssetFileSlice, user0 *User) error {
	setter := &AssetFileSetter{
		CreatedBy: omit.From(user0.ID),
	}

	err := AssetFiles.Update(ctx, exec, setter, assetFiles1...)
	if err != nil {
		return fmt.Errorf("attachUserCreatedByAssetFiles0: %w", err)
	}

	return nil
}

func (user0 *User) InsertCreatedByAssetFiles(ctx context.Context, exec bob.Executor, related ...*AssetFileSetter) error {
	if len(related) == 0 {
		return nil
	}

	assetFile1, err := insertUserCreatedByAssetFiles0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByAssetFiles = append(user0.R.CreatedByAssetFiles, assetFile1...)

	return nil
}

func (user0 *User) AttachCreatedByAssetFiles(ctx context.Context, exec bob.Executor, related ...*AssetFile) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	assetFile1 := AssetFileSlice(related)

	err = attachUserCreatedByAssetFiles0(ctx, exec, assetFile1, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByAssetFiles = append(user0.R.CreatedByAssetFiles, assetFile1...)

	return nil
}

func insertUserCreatedByAssetParts0(ctx context.Context, exec bob.Executor, assetParts1 []*AssetPartSetter, user0 *User) (AssetPartSlice, error) {
	for _, assetPart1 := range assetParts1 {
		assetPart1.CreatedBy = omit.From(user0.ID)
	}

	ret, err := AssetParts.InsertMany(ctx, exec, assetParts1...)
	if err != nil {
		return ret, fmt.Errorf("insertUserCreatedByAssetParts0: %w", err)
	}

	return ret, nil
}

func attachUserCreatedByAssetParts0(ctx context.Context, exec bob.Executor, assetParts1 AssetPartSlice, user0 *User) error {
	setter := &AssetPartSetter{
		CreatedBy: omit.From(user0.ID),
	}

	err := AssetParts.Update(ctx, exec, setter, assetParts1...)
	if err != nil {
		return fmt.Errorf("attachUserCreatedByAssetParts0: %w", err)
	}

	return nil
}

func (user0 *User) InsertCreatedByAssetParts(ctx context.Context, exec bob.Executor, related ...*AssetPartSetter) error {
	if len(related) == 0 {
		return nil
	}

	assetPart1, err := insertUserCreatedByAssetParts0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByAssetParts = append(user0.R.CreatedByAssetParts, assetPart1...)

	return nil
}

func (user0 *User) AttachCreatedByAssetParts(ctx context.Context, exec bob.Executor, related ...*AssetPart) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	assetPart1 := AssetPartSlice(related)

	err = attachUserCreatedByAssetParts0(ctx, exec, assetPart1, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByAssetParts = append(user0.R.CreatedByAssetParts, assetPart1...)

	return nil
}

func insertUserCreatedByAssets0(ctx context.Context, exec bob.Executor, assets1 []*AssetSetter, user0 *User) (AssetSlice, error) {
	for _, asset1 := range assets1 {
		asset1.CreatedBy = omit.From(user0.ID)
	}

	ret, err := Assets.InsertMany(ctx, exec, assets1...)
	if err != nil {
		return ret, fmt.Errorf("insertUserCreatedByAssets0: %w", err)
	}

	return ret, nil
}

func attachUserCreatedByAssets0(ctx context.Context, exec bob.Executor, assets1 AssetSlice, user0 *User) error {
	setter := &AssetSetter{
		CreatedBy: omit.From(user0.ID),
	}

	err := Assets.Update(ctx, exec, setter, assets1...)
	if err != nil {
		return fmt.Errorf("attachUserCreatedByAssets0: %w", err)
	}

	return nil
}

func (user0 *User) InsertCreatedByAssets(ctx context.Context, exec bob.Executor, related ...*AssetSetter) error {
	if len(related) == 0 {
		return nil
	}

	asset1, err := insertUserCreatedByAssets0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByAssets = append(user0.R.CreatedByAssets, asset1...)

	return nil
}

func (user0 *User) AttachCreatedByAssets(ctx context.Context, exec bob.Executor, related ...*Asset) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	asset1 := AssetSlice(related)

	err = attachUserCreatedByAssets0(ctx, exec, asset1, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByAssets = append(user0.R.CreatedByAssets, asset1...)

	return nil
}

func insertUserCheckedOutToAssets0(ctx context.Context, exec bob.Executor, assets1 []*AssetSetter, user0 *User) (AssetSlice, error) {
	for _, asset1 := range assets1 {
		asset1.CheckedOutTo = omitnull.From(user0.ID)
	}

	ret, err := Assets.InsertMany(ctx, exec, assets1...)
	if err != nil {
		return ret, fmt.Errorf("insertUserCheckedOutToAssets0: %w", err)
	}

	return ret, nil
}

func attachUserCheckedOutToAssets0(ctx context.Context, exec bob.Executor, assets1 AssetSlice, user0 *User) error {
	setter := &AssetSetter{
		CheckedOutTo: omitnull.From(user0.ID),
	}

	err := Assets.Update(ctx, exec, setter, assets1...)
	if err != nil {
		return fmt.Errorf("attachUserCheckedOutToAssets0: %w", err)
	}

	return nil
}

func (user0 *User) InsertCheckedOutToAssets(ctx context.Context, exec bob.Executor, related ...*AssetSetter) error {
	if len(related) == 0 {
		return nil
	}

	asset1, err := insertUserCheckedOutToAssets0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.CheckedOutToAssets = append(user0.R.CheckedOutToAssets, asset1...)

	return nil
}

func (user0 *User) AttachCheckedOutToAssets(ctx context.Context, exec bob.Executor, related ...*Asset) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	asset1 := AssetSlice(related)

	err = attachUserCheckedOutToAssets0(ctx, exec, asset1, user0)
	if err != nil {
		return err
	}

	user0.R.CheckedOutToAssets = append(user0.R.CheckedOutToAssets, asset1...)

	return nil
}
