package views

import "time"

type InputProps struct {
	Class string
	InputClass string
	InputWrapperClass string
	LabelClass string

	Value string

	Type string
	Label string
	Name string
	Placeholder string
	Required bool
	AutoComplete string
	Icon templ.Component
	ValidationErr string
}

templ Input(props InputProps) {
	<div class={ templ.SafeClass(props.Class) }>
		if props.Label != "" {
			<label for={ props.Name } class={"block mb-2 text-sm text-gray-600", templ.SafeClass(props.LabelClass)}>{ props.Label }</label>
		}

		<div class={"relative", templ.SafeClass(props.InputWrapperClass)}>
			if props.Icon != nil {
				<span class="pointer-events-none absolute ml-3 translate-y-1/2 mt-0.5 text-gray-500">
					<div class="h-4 w-4">
						{! props.Icon }
					</div>
				</span>
			}

			<input
				required?={ props.Required }
				type={ props.Type }
				name={ props.Name }
				id={ props.Name }
				if props.Placeholder != "" {
					placeholder={ props.Placeholder }
				}
				if props.AutoComplete != "" {
					auto-complete={ props.AutoComplete }
				}
				class={
					templ.SafeClass("w-full px-3 py-2 placeholder-gray-300 border border-gray-300 rounded-md focus:outline-none focus:ring focus:ring-blue-100 focus:border-blue-300"),
					templ.KV("pl-11 ", props.Icon != nil),
					templ.SafeClass(props.InputClass),
				}
				if props.Value != "" {
					value={ props.Value }
				}
			/>

			{ children... }

			if props.ValidationErr != "" {
				<span class="block text-red-500">{ props.ValidationErr }</span>
			}
		</div>
	</div>
}

type DatePickerProps struct {
	Class string
	InputClass string
	InputWrapperClass string
	LabelClass string

	Value time.Time
	Format string

	Type string
	Label string
	Name string
	Placeholder string
	Required bool
	AutoComplete string
	Icon templ.Component
	ValidationErr string
}


templ DatePicker(props DatePickerProps) {
	<div
		class={ templ.SafeClass(props.Class) }
		x-data={`{
			init() {
				return import("/static/flatpickr.min.js").catch(console.error).then(() => {
					globalThis.flatpickr($refs.picker, {
						allowInput: true,
						dateFormat: 'Y-m-d',
					})
				})
			}
		}`}
	>

		if props.Label != "" {
			<label for={ props.Name } class={"block mb-2 text-sm text-gray-600", templ.SafeClass(props.LabelClass)}>{ props.Label }</label>
		}

		<div class={"relative", templ.SafeClass(props.InputWrapperClass)}>
			if props.Icon != nil {
				<span class="pointer-events-none absolute ml-3 translate-y-1/2 mt-0.5 text-gray-500">
					<div class="h-4 w-4">
						{! props.Icon }
					</div>
				</span>
			}

			<input
				x-ref="picker"
				required?={ props.Required }
				type={ props.Type }
				name={ props.Name }
				id={ props.Name }
				if props.Placeholder != "" {
					placeholder={ props.Placeholder }
				}
				if props.AutoComplete != "" {
					auto-complete={ props.AutoComplete }
				}
				class={
					templ.SafeClass("w-full px-3 py-2 placeholder-gray-300 border border-gray-300 rounded-md focus:outline-none focus:ring focus:ring-blue-100 focus:border-blue-300"),
					templ.KV("pl-11 ", props.Icon != nil),
					templ.SafeClass(props.InputClass),
				}
				if !props.Value.IsZero() {
					value={ props.Value.Format(props.Format) }
				}
			/>

			{ children... }

			if props.ValidationErr != "" {
				<span class="block text-red-500">{ props.ValidationErr }</span>
			}
		</div>
	</div>
}

type TextareaProps struct {
	Class string
	LabelClass string
	InputClass string

	Name string
	Label string
	Placeholder string

	Value string

	ValidationErr string
}

templ Textarea(props TextareaProps) {
	<div class={ templ.SafeClass(props.Class) }>
		if props.Label != "" {
			<label for={ props.Name } class={"block mb-2 text-sm text-gray-600", templ.SafeClass(props.LabelClass)}>{ props.Label }</label>
		}

		<textarea
			class={
				templ.SafeClass("w-full h-auto min-h-[96px] px-3 py-2 bg-white border rounded-md border-neutral-300 placeholder:text-neutral-400"),
				templ.SafeClass(props.InputClass),
			}

			type="text" 
			name={props.Name}
			id={props.Name}
			placeholder={props.Placeholder}

			x-data="{resize () { 
				$el.style.height = '0px'; 
				$el.style.height = $el.scrollHeight + 'px' 
			}}"
			x-init="resize()"
			@input="resize()"
		>{props.Value}</textarea>

		if props.ValidationErr != "" {
			<span class="text-red-500">{ props.ValidationErr }</span>
		}
	</div>
}

type SelectProps struct {
	Class string
	InputClass string
	LabelClass string

	Name string
	Label string

	Selected string
	Options [][]string
}

templ Select(props SelectProps) {
	<div class={templ.SafeClass(props.Class)}>
		<label for="status" class="block mb-2 text-sm text-gray-600 font-bold">Status</label>

		<select
			name={props.Name}
			id={props.Name}
			class={
				templ.SafeClass("w-full px-1 py-2.5 rounded-md border border-gray-300"),
				templ.SafeClass(props.InputClass),
			}
			if props.Selected != "" {
				value={props.Selected}
			}
		>
			for _, o := range props.Options {
				<option
					value={o[1]}
					if o[1] == props.Selected {
						selected?={true}
					}
				>
					{ o[0] }
				</option>
			}
		</select>
	</div>
}

type AutoCompleteProps struct {
	Class string
	InputClass string
	InputWrapperClass string
	LabelClass string

	Source string
	Value string

	Type string
	Label string
	Name string
	Placeholder string
	Required bool
	Icon templ.Component
	ValidationErr string
}

templ AutoComplete(props AutoCompleteProps) {
	<div
		class={ templ.SafeClass(props.Class) }
		x-data={`{
			open: false,
			qs: null,
			items: [],
			value: "`+props.Value+`",
			async fetch() {
				if (!this.qs) {
					this.qs = new Promise(async (resolve, reject) => {
						let { QuickScore } = await import("/static/quick-score.min.js")
						let res = await fetch("`+props.Source+`")
						let opts = await res.json()
						resolve(new QuickScore(opts))
					})
				}
			},
			async onChange(el) {
				this.fetch()
				let qs = await this.qs
				if (el.value.value <= 3) {
					this.items = []
					this.open = false
					return
				}

				this.items = qs.search(el.value).map(i => i.item)

				this.open = this.items.length > 0
				if (this.open) {
					let pos = el.getBoundingClientRect()
					let top = pos.top + window.scrollY
					let left = pos.left + window.scrollX
					this.$refs.suggestions.style.left = left + 'px';
					this.$refs.suggestions.style.top = top + el.offsetHeight + 'px';
					this.$refs.suggestions.style.minWidth = el.offsetWidth + 'px';
				}
			},
			onClickSuggestion(value) {
				this.value = value
				this.open = false
			}
		}`}
	>
		if props.Label != "" {
			<label for={ props.Name } class={"block mb-2 text-sm text-gray-600", templ.SafeClass(props.LabelClass)}>{ props.Label }</label>
		}

		<div class={"relative", templ.SafeClass(props.InputWrapperClass)}>
			if props.Icon != nil {
				<span class="pointer-events-none absolute ml-3 translate-y-1/2 mt-0.5 text-gray-500">
					<div class="h-4 w-4">
						{! props.Icon }
					</div>
				</span>
			}

			<input
				@keyup.debounce.100ms="onChange($el)"
				required?={ props.Required }
				type={ props.Type }
				name={ props.Name }
				id={ props.Name }
				autocomplete="off"
				if props.Placeholder != "" {
					placeholder={ props.Placeholder }
				}
				class={
					templ.SafeClass("w-full px-3 py-2 placeholder-gray-300 border border-gray-300 rounded-md focus:outline-none focus:ring focus:ring-blue-100 focus:border-blue-300"),
					templ.KV("pl-11 ", props.Icon != nil),
					templ.SafeClass(props.InputClass),
				}
				x-bind:value="value"
			/>

			<template x-teleport="body">
				<div
					x-ref="suggestions" x-show="open"
					class="absolute top-0"
					@click.outside="open = false"
				>
					<div class="h-auto overflow-auto bg-white border rounded-md shadow-sm border-neutral-200/70">
						<ul class="divide-y divide-gray-100 text-sm w-full">
				 			<template x-for="item in items">
								<li class="w-100">
									<button
										x-text="item"
										class="p-2 blcok w-full hover:bg-blue-500 hover:text-white text-left"
										@click="onClickSuggestion(item)"
									></button>
								</li>
							</template>
						</ul>
					</div>
				</div>
			</template>

			{ children... }


			if props.ValidationErr != "" {
				<span class="block text-red-500">{ props.ValidationErr }</span>
			}
		</div>
	</div>
}

type FormProps struct {
	Class string

	Method string
	Action string
	EncType string

	SubmitButtonText string
}

templ Form(props FormProps) {
	<form
		class={templ.SafeClass(props.Class)}
		method={props.Method}
		action={props.Action}
		if props.EncType != "" {
			enctype={props.EncType}
		}
	>
		{ children... }

		@Button(ButtonProps{Type: "submit", Class: "mt-5"}) {
			{ props.SubmitButtonText }
		}
	</form>
}

